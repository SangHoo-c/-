- [x] : GIL
- [x] : reference counting
- [x] : garbage collection



### GIL (global interpreter lock)

GIL : 인터프리터가 한 스레만 하나의 바이트코드를 실행 시킬 수 있도록 해주는 LOCK. 하나의 스레드에 모든 자원을 허락하고 그 후에는 LOCK 을 걸어 다른 스레드는 실행할 수 없게 막어버리는 것. 

#### Python 에서 GIL 을 사용하는 이유 

- python :  *garbage collection* , *reference counting*  통한 메모리 관리. 
- python 의 모든 객체는 *reference count* (해당 변수가 참조된 수) 를 저장 하고 있음 
- 멀티 스레드인 경우, 여러 스레드가 하나의 객체를 사용한다면, *reference count* 를 관리하기 위해 모든 객체에 대한 lock 이 필요

**=> 엄청난 비효율.**

**비효율을 막기 위해, GIL 을 사용해서 모든 객체들에 대한 *reference count* 의 동기화 문제 해결.**



### Garbage Collection

메모리 관리 기법, 프로그램이 동적으로 할당했던 메모리 영역 중, 필요없게 된 영역을 탐지하여 자동으로 해제하는 기능

필요없게된 영역 : 어떤 변수도 가리키지 않게 된 영역

**장점** (아래와 같은 버그를 막을 수 있다.) 

- 유효하지 않은 포인터 접근
- 이중 해제 
- 메모리 누수 

**단점**

- 어떤 메모리를 해제할지 결정하는 데 비용이 든다. 사용자가 객체가 필요없어지는 시점을 미리 알고 있는 경우에도 알고리즘이 메모리 해제 시점을 추적해야 하므로, **오버헤드**가 발생한다. 
- garbage collection 이 일어나는 타이밍 & 점유시간을 예측하기 어렵다. 
- 할당된 메모리가 해제되는 시점을 알 수 없다. 



#### 포인터 추적 방식 

대부분의 garbage collection 이 사용하는 방식

한 개 이상의 변수가 *접근 가능한* 메모리는 앞으로 사용할 수 있는 메모리로 간주하고 그 밖의 메모리를 해제 

> **접근 가능한 객체 란?**
>
> 어떤 변수가 직접 가리키는 메모리, 또는 간접적으로 가리키는 메모리를 의미
>
> 1. 변수가 가리키는 객체 
> 2. 접근 가능한 객체가 가리키는 모든 객체 

#### 참조 횟수 계산 방식 

각 객체에서 참조 횟수를 기억하여, 참조 횟수가 0 이 되면 해당 객체를 해제하는 방식 

파이썬 표준 구현인 ***CPython*** 에서 이 방식을 사용

> **파이썬 구현이란 ?**
> 다양한 환경에서 Python 언어가 실행될 수 있도록 만든 프로그램 또는 시스템
>
> Python 은 CPython (표준 파이썬 구현) 에 의해 처리, 실행되는 언어 

장점 

- 객체가 *접근 불가능* 해지는 즉시 메모리가 해제되므로, 프로그래머가 객체의 해제 시점을 어느정도 예측할 수 있다. 
- 객체가 사용된 직후에 메모리를 해제하므로, 메모리 해제 시점에 해당 객체는 캐시에 저장되어 있을 확률이 높다. 
  따라서 메모리 해제가 빠르게 이루어진다. 





